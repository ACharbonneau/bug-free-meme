---
title: "Signatures of Selection SmartPCA Analysis"
author: "Amanda Charbonneau"
date: "2/17/2017"
output: html_document
---
#Overview

The STACKS pipeline may not be the best for calling SNPs in this data. It is a very conservative program, as it was written to accept everything fed into is as fact. First, it requires very strict pre-filtering, reads must be:

- High quality, STACKS ignores quality scores
- Exactly the same length
- Have an intact restriction site
- Have an intact barcode
- Have either a SNP or very small mutation

Subsequent steps are also conservative. To be used in an analysis, each individuals stack must:

- Align to the genome
- Have at least 3 identical reads
- Have 85% alignment to the reference/rest of the stacks
- Have a chi square signifigance to call it homozygous or heterozygous

Then to call SNPs between individuals populations, a given locus must:

- Be polymorphic
- Have no more than two alleles within a population
- Match only a single genomic location both within a pop and between pops
- Have a maximum of 1 mismatch
- Only be covered by a single set of stacks
- Have data for every population
- Have data for 75% of individuals in the population


Some of these parameters, like read depth per individual and how complete a locus must be, are user-settable. Others, like the restriction that sites must be biallelic, are not.

I also had it only take one (random) SNP per stack, so none of the sites used are *extremely* closely linked, however the fragmented nature of the current genome precludes avoiding linkage. This leaves the 1092 informative sites used in the following analysis.

To begin, I'm simply running the data through the same analyses that we did with the previous marker set, to see how well our previous assertions match the new data.

```{r importpackages, echo=FALSE, message=FALSE, warning=FALSE}
rm(list = ls())

# Install function for packages    
packages<-function(x){
  x<-as.character(match.call()[[2]])
  if (!require(x,character.only=TRUE)){
    install.packages(pkgs=x,repos="http://cran.r-project.org")
    require(x,character.only=TRUE)
  }
}
packages(dplyr)
packages(tidyr)
packages(RColorBrewer)
packages(ggplot2)

```

```{r ImportPythonFile, echo=FALSE, message=FALSE, warning=FALSE}

biallele <- read.table("../output/batch_20170214_biallele.csv", sep = ",", header = T)
SSmeta <- read.csv("../Metadata/SigSelection.pop", sep = "\t", header = F)
meta <- read.csv("../Metadata/SigSelectionMeta.csv")

ind <- select(biallele, SSR)
ind$SSR <- as.factor(ind$SSR)
ind <- left_join(ind, SSmeta, by=c("SSR"="V1"))
ind$U <- "U"
ind <- select(ind, SSR, U, V2)

#STRUCTURE format data from STACKS
structuredata <- data.table::fread("/Volumes/Storage/RadishData/GBS/output/batch_20170214.structure.tsv")

#Original SmartPCA run
PCA.dat <- data.table::fread("../SS_Analysis/SmartPCA/20170214.evec")

PCA.eigen <- as.data.frame(data.table::fread("../SS_Analysis/SmartPCA/20170214.eval"))

#Replicate SmartPCA run
repPCA.dat <- data.table::fread("../SS_Analysis/SmartPCArep/20170214rep.evec")

```


##SmartPCA Analysis

Previously, we looked at genetic structure with SmartPCA and data from 21 markers. SmartPCA is designed to work on human data, and so is coded to have a hard cap of 23 chromosomes. This analysis worked previously, because we had both linkage groups for those markers, and a small number of them. However, now we have a very large number of markers, and no linkage information. SmartPCA *cannot* be run with without chromosome/linkage information. Recall that SmartPCA can also only run on biallelic data. Although STACKS only outputs biallelic data, it outputs the alleles in a format that is incompatible with SmartPCA.

So, I've used a script to turn the STACKS output that is in STRUCTURE format into SmartPCA format, which fixes the incompatible biallelic format. As a hack, I've had R haphazardly assign markers to chromosomes by having it use each chromosome number 104 times (1092*2/104 = 21 chromosomes). Doing so, gives the following PCA:

```{r PlotSmartPCA, echo=FALSE, fig.keep='last', message=FALSE, warning=FALSE}

ggplot(PCA.dat, aes(V2, V3)) + geom_point(aes(col=V260)) + xlab("PC1") + ylab("PC2")

```

The user instructions for SmartPCA give very little indication of what it uses the chromosomes for. So, it's difficult to say whether this my hack is a reasonable fix, or if it is changing the outcome.

I've run a couple of tests the validity of the plot. 

###Principle Components Analysis in R of SmartPCA data
First, I've run prcomp on the exact dataframe I fed into SmartPCA, using the same color scheme for ease of comparison.

```{r PRcomp, echo=FALSE, fig.keep='last', message=FALSE, warning=FALSE}
JustPCA <- prcomp(as.data.frame(select(biallele, -SSR)))

JustPCAX <- as.data.frame(JustPCA$x)
JustPCAX$UniqID <- ind$SSR
JustPCAX <- left_join(JustPCAX, meta)


ggplot(JustPCAX, aes(PC1, PC2)) + geom_point(aes(col=Pop)) + xlab("PC1") + ylab("PC2")

```

This gives a reasonably similar, but not identical graph. Although any individual point is in a different location, the overall wishbone shape of the data is maintained, just mirrored and shifted several degrees counter-clockwise. The overall clustering of populations is also consistant. That is, the same groups of populations appear in both, and the relative posistions of sets of groups are consistant. 

Since these both use the same dataset, I expected them to give similar, if not identical, results. This close, but not exact, match suggests that SmartPCA may be using the positional information to some extent, but it could also be due to other internal algorithms of SmartPCA. 

To check this, I did a second run of SmartPCA, with a different set of fake chromosome numbers, such that the linkage would now be completely different.

##SmartPCA rerun, new chromosomes
```{r SmartPCArep, echo=FALSE, fig.keep='last', message=FALSE, warning=FALSE}


ggplot(repPCA.dat, aes(V2, V3)) + geom_point(aes(col=V260)) + xlab("PC1") + ylab("PC2")
```

This plot is exactly the same as the original SmartPCA plot, which suggests that although the program requires information about chromosome number, location and linkage, it doesn't actually use them. It appears the differences between the PRcomps and SmartPCA results are due entirely to the 'optimization for genetic data' that is part of SmartPCA, and is likely something that we want.

So, although this data doesn't fit the techinical requirements for SmartPCA, feeding it fake data for chromosome location doesn't seem to compromise the algorithm.

###Principle Components Analysis in R of original STACKS output (STRUCTURE format)

As a final check, I've run prcomp on the data that STACKS outputs in STRUCTURE format. Since the STRUCTURE format has two entries per individual per locus (one for each allele), I've simply added the values of the alleles for each locus. So, a individual that was the genotype 1, 1 is now 2. All of the genotypes output by STACKS are < 5, so this shouldn't cause too many problems with scaling, and should give a dataframe similar to the one that SmartPCA requires, just not constrained to be biallelic.

```{r strPRcomps, echo=F, warning=F}
str_A <- structuredata[seq(1, length(structuredata$V1), by = 2),]
str_B <- structuredata[seq(2, length(structuredata$V1), by = 2),]

colnames(str_A) <- paste(colnames(str_A), "_A", sep = "")
colnames(str_B) <- paste(colnames(str_B), "_B", sep = "")

strAB <- select(str_A, -V1_A) + select(str_B, -V1_B)

strPCA <- prcomp(strAB)

strPCAx <- as.data.frame(strPCA$x)

strPCAx$Indiv <- str_A$V1_A

metaPCAx <- left_join(strPCAx, SSmeta, by=c("Indiv"="V1"))

ggplot(metaPCAx, aes(PC1, PC2*-1)) + geom_point(aes(col=V2)) + xlab("PC1") + ylab("PC2")

```

Here, the overall population placements are still quite similar to the output from SmartPCA and PRcomps, however the wishbone shape has morphed into more of a circle. Given that the SmartPCA program seems to ignore chromosome data anyway, I think sticking with the SmartPCA data will be the most informative. However, it's useful to see that changing the intrinsic meaning of the allele information fed into various PCA programs doesn't make huge changes to the result, and puts populations in largely the same places relative to each other. 

###SmartPCA, Finalized plot



```{r GetPlotColors, echo=FALSE, message=FALSE, warning=FALSE}
#Set up plotting colors

## Add an alpha value to a colour
add.alpha <- function(col, alpha=.7){
  if(missing(col))
    stop("Please provide a vector of colours.")
  apply(sapply(col, col2rgb)/255, 2, 
        function(x) 
          rgb(x[1], x[2], x[3], alpha=alpha))  
}

col_pal <- brewer.pal(9, "Set1")
col6 <- brewer.pal(6, "Set2")
col_pal <- c(col_pal[c(1:5)], col6[6], col_pal[c(8,9)], "gray20", "black")

ALLTHECOLORS <- add.alpha(col_pal)

CropD.col <- ALLTHECOLORS[6]
CropE.col <- ALLTHECOLORS[1]
CropO.col <- ALLTHECOLORS[3]
CropR.col <- ALLTHECOLORS[8]

lanmar.col <- ALLTHECOLORS[7]
raphNN.col <- ALLTHECOLORS[5]
raphNatW.col <- ALLTHECOLORS[4]
rost.col <-  ALLTHECOLORS[10]

```


```{r MakeParsedData, echo=FALSE, message=FALSE, warning=FALSE}
PCA.dat <- left_join(PCA.dat, meta, by=c("V1"="UniqID"))

raphNN.data <- PCA.dat[PCA.dat$locals=="raphNN",]
lanmar.data <- PCA.dat[PCA.dat$locals=="landra",]
CropD.data <- PCA.dat[PCA.dat$locals=="daikon",]
CropE.data <- PCA.dat[PCA.dat$locals=="european",]
CropO.data <- PCA.dat[PCA.dat$locals=="oleifera",]
CropR.data <- PCA.dat[PCA.dat$local=="caudatus",]
rost.data <-  PCA.dat[PCA.dat$locals=="pugiformis",]
raphNatW.data <- PCA.dat[PCA.dat$locals=="raphNatW",]

raphNN.sym <- c(1:length(levels(droplevels(raphNN.data$Pop))))
lanmar.sym <- c(1:length(levels(droplevels(lanmar.data$Pop))))
CropD.sym <- c(1:length(levels(droplevels(CropD.data$Pop))))
CropE.sym <- c(1:length(levels(droplevels(CropE.data$Pop))))
CropO.sym <- c(1:length(levels(droplevels(CropO.data$Pop))))
CropR.sym <- c(1:length(levels(droplevels(CropR.data$Pop))))
rost.sym <- c(1:length(levels(droplevels(rost.data$Pop))))
raphNatW.sym <- c(1:length(levels(droplevels(raphNatW.data$Pop))))

```

```{r, PlotSmartPCAFinal, echo=FALSE, fig.keep='last', message=FALSE, warning=FALSE, fig.path="../figures/", fig.height=6, fig.width=8}
par( xpd=TRUE, mar=c(6,6,1,9))

PC1 <- (PCA.eigen$V1[1]/sum(PCA.eigen$V1))*100
PC2 <- (PCA.eigen$V1[2]/sum(PCA.eigen$V1))*100

plot((PCA.dat$V2 ), 
     (PCA.dat$V3 ),
     type="n", 
     xlab=paste("Eigenvector 1\n",round(PC1, digits = 1),"% of variance", sep=""), ylab=paste("Eigenvector 2\n",round(PC2, digits = 1),"% of variance", sep = ""),
     cex.lab=1.1, xlim=c(-.16, .07), ylim=c(-.16, .1))

par(new=TRUE)
plot((raphNN.data$V2 ), 
     (raphNN.data$V3 ), 
     pch=raphNN.sym[droplevels(raphNN.data$Pop)], 
     col=raphNN.col, 
     lwd=2.5,
     xlim=c(-.16, .07), ylim=c(-.16, .1),
     axes=FALSE, xlab="", ylab="", cex=1.7)

par(new=TRUE)	
plot((lanmar.data$V2 ), 
     (lanmar.data$V3 ), 
     pch=lanmar.sym[droplevels(lanmar.data$Pop)], 
     col=lanmar.col,
     lwd=2.5,
     xlim=c(-.16, .07), ylim=c(-.16, .1),
     axes=FALSE, xlab="", ylab="", cex=1.7)

par(new=TRUE)
plot((CropD.data$V2 ), 
     (CropD.data$V3 ), 
     pch=CropD.sym[droplevels(CropD.data$Pop)], 
     lwd=2.5,
     col=CropD.col, 
     xlim=c(-.16, .07), ylim=c(-.16, .1),
     axes=FALSE, xlab="", ylab="", cex=1.7)

par(new=TRUE)
plot((CropE.data$V2 ), 
     (CropE.data$V3 ), 
     pch=CropE.sym[droplevels(CropE.data$Pop)], 
     lwd=2.5,
     col=CropE.col, 
     xlim=c(-.16, .07), ylim=c(-.16, .1),
     axes=FALSE, xlab="", ylab="", cex=1.7)

par(new=TRUE)
plot((CropO.data$V2 ), 
     (CropO.data$V3 ), 
     pch=CropO.sym[droplevels(CropO.data$Pop)], 
     lwd=2.5,
     col=CropO.col, 
     xlim=c(-.16, .07), ylim=c(-.16, .1),
     axes=FALSE, xlab="", ylab="", cex=1.7)

par(new=TRUE)
plot((CropR.data$V2 ), 
     (CropR.data$V3 ), 
     pch=CropR.sym[droplevels(CropR.data$Pop)], 
     lwd=2.5,
     col=CropR.col, 
     xlim=c(-.16, .07), ylim=c(-.16, .1),
     axes=FALSE, xlab="", ylab="", cex=1.7)

par(new=TRUE)
plot((raphNatW.data$V2 ), 
     (raphNatW.data$V3 ), 
     pch=raphNatW.sym[droplevels(raphNatW.data$Pop)], 
     col=raphNatW.col, 
     lwd=2.5,
     xlim=c(-.16, .07), ylim=c(-.16, .1),
     axes=FALSE, xlab="", ylab="", cex=1.7)	

par(new=TRUE)
plot((rost.data$V2 ), 
     (rost.data$V3 ), 
     pch=rost.sym[droplevels(rost.data$Pop)], 
     col=rost.col,
     lwd=2.5,
     xlim=c(-.16, .07), ylim=c(-.16, .1),
     axes=FALSE, xlab="", ylab="", cex=1.5)		

# Landra and maritimus

rect(.081, .045, .1655, .11, col="white")
text(.124, .102, expression( "Native" ), cex=.9)
legend(.085, .1, legend=levels(droplevels(lanmar.data$Pop)), 
       pch=lanmar.sym, col=col_pal[7], title=expression(italic("R.r. landra")),
       cex=.9, ncol = 2, bty="n", pt.lwd = 2.5)

# Non Natives
rect(-.17, .03, -.08, .11, col="white")
text(-.125, .095, "Non-native" , cex=.9)
legend( -.155, .09, legend=levels(droplevels(raphNN.data$Pop)), 
        pch=raphNN.sym, col=raphNN.col, 
        title = expression( italic("R.r. raphanistrum")), cex=.9, 
       bty="n", pt.lwd = 2.5)


## R. pugioniformis
rect(.081, -.17, .1655, -.08, col="white")
text(.123, -.095, expression( "Native" ), cex=.9)
legend(.125, -.1, legend=levels(droplevels(rost.data$Pop)), 
       pch=rost.sym, xjust = .5,
       col=rost.col, title=expression(italic("R. pugioniformis")), cex=.9,
       bty="n", pt.lwd = 2.5)

# Native RRR
rect(-.17, -.17, -.08, -.08, col="white")
text(-.125, -.095, expression( "Native" ), cex=.9)
legend(-.155, -.1, legend=levels(droplevels(raphNatW.data$Pop)), 
       pch=raphNatW.sym, col=raphNatW.col,
       title = expression( italic("R.r. raphanistrum")), cex=.9, 
       bty="n", pt.lwd = 2.5)

# Crops
rect(.081, -.04, .1655, .04, col="white")
text(.124, .03, expression( "Crops" ), cex=.9)
text(.124, .02, expression(italic("R. sativus")), cex=.9)

legend(.122, .02, legend=levels(droplevels(CropD.data$Pop)), 
       pch=CropD.sym, col=CropD.col, cex=.9, 
       bty="n", pt.lwd = 2.5)

legend(.122, -.001, legend=levels(droplevels(CropE.data$Pop)), 
       pch=CropE.sym, col=CropE.col, cex=.9,
       bty="n", pt.lwd = 2.5)

legend(.085, .02, legend=levels(droplevels(CropO.data$Pop)), 
       pch=CropO.sym, col=CropO.col, cex=.9, 
       bty="n", pt.lwd = 2.5)

legend(.085, -.001, legend=levels(droplevels(CropR.data$Pop)), 
       pch=CropR.sym, col=CropR.col, cex=.9,
       bty="n", pt.lwd = 2.5)

```

Excitingly, this plot looks largely the same as the one done with 21 markers for the last paper. The crops all cluster together, landra and native R.r. raphanistrum populations flank the weeds, and R. pugioniformis is off on it's own. This plot is a little cleaner, however, and much more strongly suggests that the weeds are a landra/raphanistrum hybrid. It also much more clearly shows that the crops could be hybrids of pugioniformis and landra. 

Overall, this plot agrees with our current data, and supports all of our major points in the previous paper.
